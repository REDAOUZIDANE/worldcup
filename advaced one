#!/bin/bash

# 1. Create project structure with marketplace components
mkdir -p vamosway/{static/{css,js,images/uploads},templates/{auth,admin,marketplace},models,services,migrations,blueprints}
cd vamosway

# 2. Set up Python environment with Kali Linux compatibility
sudo apt-get update
sudo apt-get install python3 python3-pip python3-venv libpq-dev python3-dev -y
python3 -m venv venv
source venkiv/bin/activate

# Install advanced requirements with versions
pip install flask==2.3.2 flask-login==0.6.2 flask-sqlalchemy==3.0.3 flask-migrate==4.0.4 \
    openai==0.27.8 pillow==10.0.0 python-dotenv==1.0.0 requests==2.31.0 \
    stability-sdk==0.4.0 python-multipart==0.0.6 email-validator==2.0.0.post2 \
    pyjwt==2.7.0 cryptography==41.0.3 flask-wtf==1.1.1 flask-limiter==3.3.0 \
    psycopg2-binary==2.9.6 stripe==5.5.0 flask-admin==1.6.1 flask-security==4.1.0 \
    redis==4.5.5 celery==5.3.1 flask-socketio==5.3.4

# 3. Create main application file with enhanced security and marketplace
cat > app.py << 'EOL'
import os
from flask import Flask, render_template, request, jsonify, redirect, url_for, flash
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import secure_filename
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from datetime import datetime, timedelta
import jwt
from email_validator import validate_email, EmailNotValidError
from dotenv import load_dotenv
import uuid
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_wtf.csrf import CSRFProtect
from flask_mail import Mail
from flask_security import Security, SQLAlchemyUserDatastore
import logging
from logging.handlers import RotatingFileHandler

# Load environment variables
load_dotenv()

# Configure logging
if not os.path.exists('logs'):
    os.mkdir('logs')
file_handler = RotatingFileHandler('logs/vamosway.log', maxBytes=10240, backupCount=10)
file_handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
file_handler.setLevel(logging.INFO)

# Initialize Flask app
app = Flask(__name__)
app.config.update(
    SECRET_KEY=os.getenv('SECRET_KEY'),
    SQLALCHEMY_DATABASE_URI=os.getenv('DATABASE_URL', 'sqlite:///vamosway.db'),
    SQLALCHEMY_TRACK_MODIFICATIONS=False,
    UPLOAD_FOLDER='static/images/uploads',
    MAX_CONTENT_LENGTH=16 * 1024 * 1024,  # 16MB
    JWT_SECRET_KEY=os.getenv('JWT_SECRET_KEY'),
    JWT_ACCESS_TOKEN_EXPIRES=timedelta(hours=1),
    MAIL_SERVER=os.getenv('MAIL_SERVER'),
    MAIL_PORT=int(os.getenv('MAIL_PORT', 587)),
    MAIL_USE_TLS=os.getenv('MAIL_USE_TLS', 'True') == 'True',
    MAIL_USERNAME=os.getenv('MAIL_USERNAME'),
    MAIL_PASSWORD=os.getenv('MAIL_PASSWORD'),
    MAIL_DEFAULT_SENDER=os.getenv('MAIL_DEFAULT_SENDER'),
    SECURITY_PASSWORD_SALT=os.getenv('SECURITY_PASSWORD_SALT'),
    STRIPE_PUBLIC_KEY=os.getenv('STRIPE_PUBLIC_KEY'),
    STRIPE_SECRET_KEY=os.getenv('STRIPE_SECRET_KEY'),
    CELERY_BROKER_URL=os.getenv('CELERY_BROKER_URL', 'redis://localhost:6379/0'),
    CELERY_RESULT_BACKEND=os.getenv('CELERY_RESULT_BACKEND', 'redis://localhost:6379/0'),
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax',
    PERMANENT_SESSION_LIFETIME=timedelta(days=30),
    RATELIMIT_STORAGE_URL=os.getenv('RATELIMIT_STORAGE_URL', 'memory://')
)

# Initialize extensions
db = SQLAlchemy(app)
migrate = Migrate(app, db)
login_manager = LoginManager(app)
login_manager.login_view = 'auth.login'
csrf = CSRFProtect(app)
mail = Mail(app)
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

# Security headers middleware
@app.after_request
def apply_security_headers(response):
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    if 'Cache-Control' not in response.headers:
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'
    return response

# Import models after db initialization
from models import User, UserProfile, Role, Product, Order, OrderItem, Payment, Review

# Setup Flask-Security
user_datastore = SQLAlchemyUserDatastore(db, User, Role)
security = Security(app, user_datastore)

# Import blueprints
from blueprints.auth import auth_bp
from blueprints.admin import admin_bp
from blueprints.marketplace import marketplace_bp
from blueprints.api import api_bp

# Register blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(admin_bp)
app.register_blueprint(marketplace_bp)
app.register_blueprint(api_bp, url_prefix='/api/v1')

# Initialize Celery
from celery import Celery
celery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])
celery.conf.update(app.config)

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

@app.route('/')
def home():
    featured_products = Product.query.filter_by(is_featured=True).limit(4).all()
    return render_template('index.html', featured_products=featured_products)

@app.route('/profile')
@login_required
def profile():
    return render_template('profile.html', user=current_user)

# Error handlers
@app.errorhandler(404)
def page_not_found(e):
    return render_template('errors/404.html'), 404

@app.errorhandler(403)
def forbidden(e):
    return render_template('errors/403.html'), 403

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('errors/500.html'), 500

if __name__ == '__main__':
    app.logger.addHandler(file_handler)
    app.logger.setLevel(logging.INFO)
    app.logger.info('VamosWay startup')
    app.run(ssl_context='adhoc' if os.getenv('FLASK_ENV') == 'production' else None)
EOL

# 4. Create enhanced auth blueprint with OAuth
mkdir -p blueprints
cat > blueprints/auth.py << 'EOL'
from flask import Blueprint, render_template, redirect, url_for, flash, request, current_app
from flask_login import login_user, logout_user, current_user
from werkzeug.security import generate_password_hash, check_password_hash
from models import User, UserProfile, Role, db
from services.auth_service import send_verification_email, send_password_reset_email
from email_validator import validate_email, EmailNotValidError
import jwt
from datetime import datetime, timedelta
from app import csrf, limiter
from flask_security import roles_required
from oauthlib.oauth2 import WebApplicationClient
import requests
import os

auth_bp = Blueprint('auth', __name__)

# OAuth2 client setup
GOOGLE_CLIENT_ID = os.getenv('GOOGLE_CLIENT_ID')
GOOGLE_CLIENT_SECRET = os.getenv('GOOGLE_CLIENT_SECRET')
GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"

client = WebApplicationClient(GOOGLE_CLIENT_ID)

@auth_bp.route('/register', methods=['GET', 'POST'])
@limiter.limit("5 per minute")
def register():
    if current_user.is_authenticated:
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        
        # Validate inputs
        errors = []
        
        try:
            valid = validate_email(email)
            email = valid.email
        except EmailNotValidError:
            errors.append('Invalid email address')
            
        if User.query.filter_by(email=email).first():
            errors.append('Email already registered')
            
        if len(password) < 12:
            errors.append('Password must be at least 12 characters')
            
        if not any(char.isdigit() for char in password):
            errors.append('Password must contain at least one number')
            
        if not any(char.isupper() for char in password):
            errors.append('Password must contain at least one uppercase letter')
            
        if not any(char.islower() for char in password):
            errors.append('Password must contain at least one lowercase letter')
            
        if password != confirm_password:
            errors.append('Passwords do not match')
            
        if errors:
            for error in errors:
                flash(error, 'danger')
            return redirect(url_for('auth.register'))
        
        # Create user
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256:600000')
        new_user = User(
            email=email,
            password=hashed_password,
            email_verified=False,
            active=True
        )
        db.session.add(new_user)
        db.session.commit()
        
        # Add user role
        user_role = Role.query.filter_by(name='user').first()
        if user_role:
            new_user.roles.append(user_role)
            db.session.commit()
        
        # Create user profile
        profile = UserProfile(
            user_id=new_user.id,
            first_name=first_name,
            last_name=last_name,
            created_at=datetime.utcnow()
        )
        db.session.add(profile)
        db.session.commit()
        
        # Send verification email
        send_verification_email(new_user)
        
        flash('Registration successful! Please check your email to verify your account.', 'success')
        return redirect(url_for('auth.login'))
    
    return render_template('auth/register.html')

@auth_bp.route('/login', methods=['GET', 'POST'])
@limiter.limit("10 per minute")
def login():
    if current_user.is_authenticated:
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        remember = True if request.form.get('remember') else False
        
        user = User.query.filter_by(email=email).first()
        
        if not user or not check_password_hash(user.password, password):
            flash('Invalid email or password', 'danger')
            return redirect(url_for('auth.login'))
            
        if not user.email_verified:
            flash('Please verify your email before logging in', 'warning')
            return redirect(url_for('auth.login'))
            
        if not user.active:
            flash('Account is disabled', 'danger')
            return redirect(url_for('auth.login'))
            
        login_user(user, remember=remember)
        user.last_login = datetime.utcnow()
        db.session.commit()
        
        flash('Logged in successfully!', 'success')
        next_page = request.args.get('next')
        return redirect(next_page or url_for('marketplace.home')))
    
    return render_template('auth/login.html')

@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out', 'info')
    return redirect(url_for('home'))

@auth_bp.route('/login/google')
def google_login():
    google_provider_cfg = requests.get(GOOGLE_DISCOVERY_URL).json()
    authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    
    request_uri = client.prepare_request_uri(
        authorization_endpoint,
        redirect_uri=request.base_url + "/callback",
        scope=["openid", "email", "profile"],
    )
    return redirect(request_uri)

@auth_bp.route("/login/google/callback")
def google_callback():
    code = request.args.get("code")
    google_provider_cfg = requests.get(GOOGLE_DISCOVERY_URL).json()
    token_endpoint = google_provider_cfg["token_endpoint"]
    
    token_url, headers, body = client.prepare_token_request(
        token_endpoint,
        authorization_response=request.url,
        redirect_url=request.base_url,
        code=code
    )
    token_response = requests.post(
        token_url,
        headers=headers,
        data=body,
        auth=(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET),
    )
    
    client.parse_request_body_response(token_response.text)
    
    userinfo_endpoint = google_provider_cfg["userinfo_endpoint"]
    uri, headers, body = client.add_token(userinfo_endpoint)
    userinfo_response = requests.get(uri, headers=headers, data=body)
    
    if userinfo_response.json().get("email_verified"):
        unique_id = userinfo_response.json()["sub"]
        users_email = userinfo_response.json()["email"]
        users_name = userinfo_response.json()["given_name"]
    else:
        flash("User email not available or not verified by Google.", "danger")
        return redirect(url_for("auth.login"))
    
    user = User.query.filter_by(email=users_email).first()
    
    if not user:
        user = User(
            email=users_email,
            password=generate_password_hash(str(uuid.uuid4())),
            email_verified=True,
            active=True
        )
        db.session.add(user)
        db.session.commit()
        
        profile = UserProfile(
            user_id=user.id,
            first_name=users_name,
            created_at=datetime.utcnow()
        )
        db.session.add(profile)
        db.session.commit()
        
        user_role = Role.query.filter_by(name='user').first()
        if user_role:
            user.roles.append(user_role)
            db.session.commit()
    
    login_user(user)
    user.last_login = datetime.utcnow()
    db.session.commit()
    
    flash(f'Logged in as {users_email}', 'success')
    return redirect(url_for('marketplace.home'))
EOL

# 5. Create marketplace blueprint
cat > blueprints/marketplace.py << 'EOL'
from flask import Blueprint, render_template, redirect, url_for, flash, request, abort
from flask_login import login_required, current_user
from models import Product, Order, OrderItem, Review, db
from app import csrf, limiter
from datetime import datetime
from werkzeug.utils import secure_filename
import os
from services.payment_service import create_stripe_checkout_session
from forms import ProductForm, ReviewForm

marketplace_bp = Blueprint('marketplace', __name__)

@marketplace_bp.route('/')
def home():
    page = request.args.get('page', 1, type=int)
    per_page = 12
    products = Product.query.filter_by(is_active=True).order_by(
        Product.created_at.desc()).paginate(page=page, per_page=per_page)
    return render_template('marketplace/home.html', products=products)

@marketplace_bp.route('/product/<int:product_id>')
def product_detail(product_id):
    product = Product.query.get_or_404(product_id)
    if not product.is_active and not (current_user.is_authenticated and current_user.has_role('admin')):
        abort(404)
    
    form = ReviewForm()
    reviews = Review.query.filter_by(product_id=product_id).order_by(
        Review.created_at.desc()).limit(10).all()
    
    return render_template('marketplace/product_detail.html', 
                         product=product, 
                         form=form,
                         reviews=reviews)

@marketplace_bp.route('/product/add', methods=['GET', 'POST'])
@login_required
def add_product():
    form = ProductForm()
    if form.validate_on_submit():
        product = Product(
            name=form.name.data,
            description=form.description.data,
            price=form.price.data,
            stock=form.stock.data,
            user_id=current_user.id,
            category=form.category.data,
            is_active=True
        )
        
        if form.image.data:
            filename = secure_filename(form.image.data.filename)
            filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            form.image.data.save(filepath)
            product.image_url = url_for('static', filename=f'images/uploads/{filename}')
        
        db.session.add(product)
        db.session.commit()
        
        flash('Product added successfully!', 'success')
        return redirect(url_for('marketplace.product_detail', product_id=product.id))
    
    return render_template('marketplace/add_product.html', form=form)

@marketplace_bp.route('/cart')
@login_required
def view_cart():
    # Implement cart functionality
    return render_template('marketplace/cart.html')

@marketplace_bp.route('/checkout', methods=['POST'])
@login_required
@csrf.exempt
def checkout():
    try:
        # Get cart items from session or database
        cart_items = []  # Replace with actual cart items
        
        if not cart_items:
            flash('Your cart is empty', 'warning')
            return redirect(url_for('marketplace.view_cart'))
        
        line_items = []
        for item in cart_items:
            line_items.append({
                'price_data': {
                    'currency': 'usd',
                    'product_data': {
                        'name': item['product'].name,
                    },
                    'unit_amount': int(item['product'].price * 100),
                },
                'quantity': item['quantity'],
            })
        
        checkout_session = create_stripe_checkout_session(
            line_items=line_items,
            customer_email=current_user.email,
            success_url=url_for('marketplace.payment_success', _external=True),
            cancel_url=url_for('marketplace.view_cart', _external=True)
        )
        
        return redirect(checkout_session.url, code=303)
    except Exception as e:
        current_app.logger.error(f"Checkout error: {str(e)}")
        flash('An error occurred during checkout. Please try again.', 'danger')
        return redirect(url_for('marketplace.view_cart'))

@marketplace_bp.route('/payment/success')
@login_required
def payment_success():
    # Handle successful payment
    session_id = request.args.get('session_id')
    
    try:
        # Retrieve checkout session from Stripe
        checkout_session = stripe.checkout.Session.retrieve(session_id)
        
        # Create order in database
        order = Order(
            user_id=current_user.id,
            total_amount=checkout_session.amount_total / 100,
            payment_status='completed',
            stripe_session_id=session_id
        )
        db.session.add(order)
        db.session.commit()
        
        # Add order items
        line_items = stripe.checkout.Session.list_line_items(session_id)
        for item in line_items:
            product = Product.query.get(int(item.description.split('#')[1]))
            order_item = OrderItem(
                order_id=order.id,
                product_id=product.id,
                quantity=item.quantity,
                price=item.price.unit_amount / 100
            )
            db.session.add(order_item)
            
            # Update product stock
            product.stock -= item.quantity
            db.session.add(product)
        
        db.session.commit()
        
        flash('Payment successful! Thank you for your purchase.', 'success')
        return redirect(url_for('marketplace.order_detail', order_id=order.id))
    except Exception as e:
        current_app.logger.error(f"Payment success error: {str(e)}")
        flash('We received your payment but encountered an issue recording it. Please contact support.', 'warning')
        return redirect(url_for('marketplace.orders'))

@marketplace_bp.route('/orders')
@login_required
def orders():
    orders = Order.query.filter_by(user_id=current_user.id).order_by(
        Order.created_at.desc()).all()
    return render_template('marketplace/orders.html', orders=orders)

@marketplace_bp.route('/orders/<int:order_id>')
@login_required
def order_detail(order_id):
    order = Order.query.get_or_404(order_id)
    if order.user_id != current_user.id and not current_user.has_role('admin'):
        abort(403)
    
    return render_template('marketplace/order_detail.html', order=order)

@marketplace_bp.route('/review/<int:product_id>', methods=['POST'])
@login_required
@limiter.limit("2 per day")
def add_review(product_id):
    form = ReviewForm()
    product = Product.query.get_or_404(product_id)
    
    # Check if user has purchased the product
    has_purchased = OrderItem.query.join(Order).filter(
        Order.user_id == current_user.id,
        OrderItem.product_id == product_id,
        Order.payment_status == 'completed'
    ).first()
    
    if not has_purchased and not current_user.has_role('admin'):
        flash('You can only review products you have purchased', 'danger')
        return redirect(url_for('marketplace.product_detail', product_id=product_id))
    
    if form.validate_on_submit():
        review = Review(
            user_id=current_user.id,
            product_id=product_id,
            rating=form.rating.data,
            comment=form.comment.data
        )
        db.session.add(review)
        
        # Update product rating
        product.update_rating()
        
        db.session.commit()
        flash('Review submitted successfully!', 'success')
    
    return redirect(url_for('marketplace.product_detail', product_id=product_id))
EOL

# 6. Create API blueprint
cat > blueprints/api.py << 'EOL'
from flask import Blueprint, jsonify, request
from flask_login import current_user
from models import Product, User
from app import db, limiter
from flask_limiter import RateLimitExceeded
from functools import wraps
import jwt
from datetime import datetime, timedelta

api_bp = Blueprint('api', __name__)

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Token is missing'}), 401
        
        try:
            data = jwt.decode(token.split()[1], current_app.config['SECRET_KEY'], algorithms=['HS256'])
            current_user = User.query.get(data['user_id'])
        except:
            return jsonify({'message': 'Token is invalid'}), 401
        
        return f(current_user, *args, **kwargs)
    return decorated

@api_bp.errorhandler(RateLimitExceeded)
def handle_rate_limit_exceeded(e):
    return jsonify({
        "error": "rate_limit_exceeded",
        "message": "Too many requests"
    }), 429

@api_bp.route('/products', methods=['GET'])
@limiter.limit("100 per minute")
def get_products():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    products = Product.query.filter_by(is_active=True).paginate(page=page, per_page=per_page)
    
    return jsonify({
        'products': [{
            'id': product.id,
            'name': product.name,
            'description': product.description,
            'price': product.price,
            'image_url': product.image_url,
            'rating': product.rating
        } for product in products.items],
        'total': products.total,
        'pages': products.pages,
        'current_page': products.page
    })

@api_bp.route('/products/<int:product_id>', methods=['GET'])
def get_product(product_id):
    product = Product.query.get_or_404(product_id)
    if not product.is_active:
        return jsonify({'message': 'Product not found'}), 404
    
    return jsonify({
        'id': product.id,
        'name': product.name,
        'description': product.description,
        'price': product.price,
        'image_url': product.image_url,
        'rating': product.rating,
        'stock': product.stock,
        'reviews_count': product.reviews.count()
    })

@api_bp.route('/products', methods=['POST'])
@token_required
@limiter.limit("10 per hour")
def create_product(current_user):
    data = request.get_json()
    
    if not data or not all(key in data for key in ['name', 'description', 'price']):
        return jsonify({'message': 'Missing required fields'}), 400
    
    product = Product(
        name=data['name'],
        description=data['description'],
        price=data['price'],
        user_id=current_user.id,
        stock=data.get('stock', 1),
        category=data.get('category', 'other'),
        is_active=True
    )
    
    db.session.add(product)
    db.session.commit()
    
    return jsonify({
        'message': 'Product created successfully',
        'product_id': product.id
    }), 201

@api_bp.route('/auth/token', methods=['POST'])
def get_token():
    auth = request.authorization
    if not auth or not auth.username or not auth.password:
        return jsonify({'message': 'Could not verify'}), 401
    
    user = User.query.filter_by(email=auth.username).first()
    if not user or not user.check_password(auth.password):
        return jsonify({'message': 'Invalid credentials'}), 401
    
    token = jwt.encode({
        'user_id': user.id,
        'exp': datetime.utcnow() + timedelta(hours=24)
    }, current_app.config['SECRET_KEY'])
    
    return jsonify({'token': token.decode('UTF-8')})
EOL

# 7. Create enhanced models
cat > models.py << 'EOL'
from app import db
from flask_login import UserMixin
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy import event
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.sql import func

roles_users = db.Table('roles_users',
    db.Column('user_id', db.Integer(), db.ForeignKey('user.id')),
    db.Column('role_id', db.Integer(), db.ForeignKey('role.id'))
)

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password = db.Column(db.String(255), nullable=False)
    email_verified = db.Column(db.Boolean, default=False)
    active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_login = db.Column(db.DateTime)
    profile = db.relationship('UserProfile', backref='user', uselist=False, cascade='all, delete-orphan')
    products = db.relationship('Product', backref='seller', lazy='dynamic')
    orders = db.relationship('Order', backref='customer', lazy='dynamic')
    reviews = db.relationship('Review', backref='author', lazy='dynamic')
    roles = db.relationship('Role', secondary=roles_users, backref=db.backref('users', lazy='dynamic'))
    
    def set_password(self, password):
        self.password = generate_password_hash(password, method='pbkdf2:sha256:600000')
    
    def check_password(self, password):
        return check_password_hash(self.password, password)
    
    def has_role(self, role_name):
        return any(role.name == role_name for role in self.roles)
    
    def get_reset_token(self, expires_in=3600):
        import jwt
        return jwt.encode(
            {'user_id': self.id, 'exp': datetime.utcnow() + timedelta(seconds=expires_in)},
            current_app.config['SECRET_KEY'],
            algorithm='HS256'
        )
    
    def __repr__(self):
        return f'<User {self.email}>'

class UserProfile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True)
    first_name = db.Column(db.String(50))
    last_name = db.Column(db.String(50))
    phone = db.Column(db.String(20))
    address = db.Column(db.String(200))
    city = db.Column(db.String(50))
    country = db.Column(db.String(50))
    profile_picture = db.Column(db.String(100))
    bio = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    
    @hybrid_property
    def full_name(self):
        return f'{self.first_name} {self.last_name}'
    
    def __repr__(self):
        return f'<UserProfile {self.user_id}>'

class Role(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True)
    description = db.Column(db.String(200))
    
    def __repr__(self):
        return f'<Role {self.name}>'

class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, index=True)
    description = db.Column(db.Text, nullable=False)
    price = db.Column(db.Float, nullable=False)
    stock = db.Column(db.Integer, default=1)
    image_url = db.Column(db.String(200))
    rating = db.Column(db.Float, default=0.0)
    is_featured = db.Column(db.Boolean, default=False)
    is_active = db.Column(db.Boolean, default=True)
    category = db.Column(db.String(50), index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    reviews = db.relationship('Review', backref='product', lazy='dynamic', cascade='all, delete-orphan')
    order_items = db.relationship('OrderItem', backref='product', lazy='dynamic')
    
    def update_rating(self):
        avg_rating = db.session.query(func.avg(Review.rating)).filter(
            Review.product_id == self.id).scalar()
        self.rating = round(avg_rating or 0, 1)
    
    def __repr__(self):
        return f'<Product {self.name}>'

class Order(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    total_amount = db.Column(db.Float, nullable=False)
    payment_status = db.Column(db.String(20), default='pending')
    stripe_session_id = db.Column(db.String(100))
    shipping_address = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    items = db.relationship('OrderItem', backref='order', lazy='dynamic', cascade='all, delete-orphan')
    payment = db.relationship('Payment', backref='order', uselist=False, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<Order {self.id}>'

class OrderItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'))
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'))
    quantity = db.Column(db.Integer, default=1)
    price = db.Column(db.Float, nullable=False)
    
    def __repr__(self):
        return f'<OrderItem {self.id}>'

class Payment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'))
    amount = db.Column(db.Float, nullable=False)
    payment_method = db.Column(db.String(50))
    transaction_id = db.Column(db.String(100))
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<Payment {self.transaction_id}>'

class Review(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'))
    rating = db.Column(db.Integer, nullable=False)
    comment = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    __table_args__ = (
        db.UniqueConstraint('user_id', 'product_id', name='_user_product_uc'),
    )
    
    def __repr__(self):
        return f'<Review {self.id}>'

# Create default roles on first run
@event.listens_for(Role.__table__, 'after_create')
def create_roles(*args, **kwargs):
    db.session.add(Role(name='admin', description='Administrator with full access'))
    db.session.add(Role(name='user', description='Regular user'))
    db.session.commit()
EOL

# 8. Create services
mkdir -p services
cat > services/auth_service.py << 'EOL'
import jwt
from datetime import datetime, timedelta
from flask import url_for, render_template, current_app
from app import mail
from flask_mail import Message
from models import User, PasswordResetToken, db
import logging
from itsdangerous import URLSafeTimedSerializer

logger = logging.getLogger(__name__)

def send_verification_email(user):
    try:
        token = user.get_reset_token()
        verify_url = url_for('auth.verify_email', token=token, _external=True)
        
        msg = Message("Verify Your Email - VamosWay",
                      recipients=[user.email])
        msg.body = render_template('emails/verify_email.txt', verify_url=verify_url)
        msg.html = render_template('emails/verify_email.html', verify_url=verify_url)
        
        mail.send(msg)
        logger.info(f"Verification email sent to {user.email}")
    except Exception as e:
        logger.error(f"Error sending verification email to {user.email}: {str(e)}")

def send_password_reset_email(user):
    try:
        token = user.get_reset_token()
        expires_at = datetime.utcnow() + timedelta(hours=1)
        
        # Invalidate any existing tokens
        PasswordResetToken.query.filter_by(user_id=user.id, used=False).update({'used': True})
        
        # Store the new token
        reset_token = PasswordResetToken(
            user_id=user.id,
            token=token,
            expires_at=expires_at
        )
        db.session.add(reset_token)
        db.session.commit()
        
        reset_url = url_for('auth.reset_password', token=token, _external=True)
        
        msg = Message("Password Reset Request - VamosWay",
                      recipients=[user.email])
        msg.body = render_template('emails/reset_password.txt', reset_url=reset_url)
        msg.html = render_template('emails/reset_password.html', reset_url=reset_url)
        
        mail.send(msg)
        logger.info(f"Password reset email sent to {user.email}")
    except Exception as e:
        logger.error(f"Error sending password reset email to {user.email}: {str(e)}")
        db.session.rollback()

def generate_confirmation_token(email):
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    return serializer.dumps(email, salt=current_app.config['SECURITY_PASSWORD_SALT'])

def confirm_token(token, expiration=3600):
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        email = serializer.loads(
            token,
            salt=current_app.config['SECURITY_PASSWORD_SALT'],
            max_age=expiration
        )
    except:
        return False
    return email
EOL

cat > services/payment_service.py << 'EOL'
import stripe
from flask import current_app
from datetime import datetime
from models import Payment, db
import logging

logger = logging.getLogger(__name__)

def init_stripe():
    stripe.api_key = current_app.config['STRIPE_SECRET_KEY']

def create_stripe_checkout_session(line_items, customer_email, success_url, cancel_url):
    init_stripe()
    
    try:
        session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=line_items,
            mode='payment',
            customer_email=customer_email,
            success_url=success_url,
            cancel_url=cancel_url,
            metadata={'created_at': datetime.utcnow().isoformat()}
        )
        return session
    except stripe.error.StripeError as e:
        logger.error(f"Stripe error creating checkout session: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"Error creating checkout session: {str(e)}")
        raise

def handle_stripe_webhook(payload, sig_header):
    init_stripe()
    endpoint_secret = current_app.config['STRIPE_WEBHOOK_SECRET']
    event = None
    
    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, endpoint_secret
        )
    except ValueError as e:
        logger.error(f"Invalid Stripe payload: {str(e)}")
        raise
    except stripe.error.SignatureVerificationError as e:
        logger.error(f"Invalid Stripe signature: {str(e)}")
        raise
    
    # Handle the event
    if event['type'] == 'checkout.session.completed':
        session = event['data']['object']
        handle_checkout_session(session)
    elif event['type'] == 'payment_intent.succeeded':
        payment_intent = event['data']['object']
        logger.info(f"Payment succeeded: {payment_intent['id']}")
    else:
        logger.info(f"Unhandled event type: {event['type']}")
    
    return event

def handle_checkout_session(session):
    try:
        # Check if order already exists
        order = Order.query.filter_by(stripe_session_id=session.id).first()
        if order:
            logger.warning(f"Order already exists for session {session.id}")
            return
        
        # Create new order
        order = Order(
            user_id=User.query.filter_by(email=session.customer_email).first().id,
            total_amount=session.amount_total / 100,
            payment_status='completed',
            stripe_session_id=session.id,
            created_at=datetime.fromisoformat(session.metadata['created_at'])
        )
        db.session.add(order)
        
        # Add order items
        line_items = stripe.checkout.Session.list_line_items(session.id)
        for item in line_items:
            product_id = int(item.description.split('#')[1])
            product = Product.query.get(product_id)
            
            order_item = OrderItem(
                order_id=order.id,
                product_id=product_id,
                quantity=item.quantity,
                price=item.price.unit_amount / 100
            )
            db.session.add(order_item)
            
            # Update product stock
            product.stock -= item.quantity
            db.session.add(product)
        
        # Create payment record
        payment = Payment(
            order_id=order.id,
            amount=session.amount_total / 100,
            payment_method='stripe',
            transaction_id=session.payment_intent,
            status='completed'
        )
        db.session.add(payment)
        
        db.session.commit()
        logger.info(f"Created order {order.id} from Stripe session {session.id}")
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error handling checkout session {session.id}: {str(e)}")
        raise
EOL

# 9. Create forms
mkdir -p forms
cat > forms/__init__.py << 'EOL'
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField, TextAreaField, \
    IntegerField, DecimalField, SelectField, FileField, HiddenField
from wtforms.validators import DataRequired, Email, EqualTo, Length, \
    ValidationError, NumberRange
from flask_wtf.file import FileAllowed
from models import User

class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    remember = HiddenField('Remember me')
    submit = SubmitField('Login')

class RegistrationForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[
        DataRequired(),
        Length(min=12, message='Password must be at least 12 characters long')
    ])
    confirm_password = PasswordField('Confirm Password', validators=[
        DataRequired(),
        EqualTo('password', message='Passwords must match')
    ])
    first_name = StringField('First Name', validators=[DataRequired(), Length(max=50)])
    last_name = StringField('Last Name', validators=[DataRequired(), Length(max=50)])
    submit = SubmitField('Register')

    def validate_email(self, email):
        user = User.query.filter_by(email=email.data).first()
        if user:
            raise ValidationError('Email already registered. Please use a different email.')

class ProductForm(FlaskForm):
    name = StringField('Product Name', validators=[
        DataRequired(),
        Length(max=100, message='Name cannot exceed 100 characters')
    ])
    description = TextAreaField('Description', validators=[
        DataRequired(),
        Length(max=2000, message='Description cannot exceed 2000 characters')
    ])
    price = DecimalField('Price', validators=[
        DataRequired(),
        NumberRange(min=0.01, message='Price must be at least $0.01')
    ], places=2)
    stock = IntegerField('Stock Quantity', validators=[
        DataRequired(),
        NumberRange(min=0, message='Stock cannot be negative')
    ], default=1)
    category = SelectField('Category', choices=[
        ('electronics', 'Electronics'),
        ('clothing', 'Clothing'),
        ('home', 'Home & Garden'),
        ('books', 'Books'),
        ('other', 'Other')
    ], validators=[DataRequired()])
    image = FileField('Product Image', validators=[
        FileAllowed(['jpg', 'jpeg', 'png'], 'Images only!')
    ])
    submit = SubmitField('Add Product')

class ReviewForm(FlaskForm):
    rating = SelectField('Rating', choices=[
        (5, '5 Stars'),
        (4, '4 Stars'),
        (3, '3 Stars'),
        (2, '2 Stars'),
        (1, '1 Star')
    ], validators=[DataRequired()], coerce=int)
    comment = TextAreaField('Review Comment', validators=[
        Length(max=1000, message='Comment cannot exceed 1000 characters')
    ])
    submit = SubmitField('Submit Review')
EOL

# 10. Create templates
mkdir -p templates/{auth,admin,marketplace,emails,errors,includes}

# Base template
cat > templates/base.html << 'EOL'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="VamosWay Marketplace - Your one-stop shop for unique products">
    <meta name="keywords" content="marketplace, shopping, ecommerce">
    <meta name="author" content="VamosWay">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{% block title %}VamosWay Marketplace{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    {% block extra_css %}{% endblock %}
</head>
<body>
    {% include 'includes/navbar.html' %}
    
    <div class="container mt-4">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                        {{ message }}
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}
        
        {% block content %}{% endblock %}
    </div>
    
    {% include 'includes/footer.html' %}
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://js.stripe.com/v3/"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
    {% block extra_js %}{% endblock %}
</body>
</html>
EOL

# Navbar
cat > templates/includes/navbar.html << 'EOL'
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
        <a class="navbar-brand" href="{{ url_for('home') }}">VamosWay</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav me-auto">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('marketplace.home') }}">Marketplace</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Categories</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                {% if current_user.is_authenticated %}
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown">
                            <i class="bi bi-person-circle"></i> {{ current_user.profile.first_name or 'Account' }}
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end">
                            <li><a class="dropdown-item" href="{{ url_for('profile') }}">Profile</a></li>
                            <li><a class="dropdown-item" href="{{ url_for('marketplace.orders') }}">My Orders</a></li>
                            {% if current_user.has_role('admin') %}
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="{{ url_for('admin.dashboard') }}">Admin Dashboard</a></li>
                            {% endif %}
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="{{ url_for('auth.logout') }}">Logout</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link position-relative" href="{{ url_for('marketplace.view_cart') }}">
                            <i class="bi bi-cart3"></i>
                            <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger">
                                0
                            </span>
                        </a>
                    </li>
                {% else %}
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('auth.login') }}">Login</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('auth.register') }}">Register</a>
                    </li>
                {% endif %}
            </ul>
        </div>
    </div>
</nav>
EOL

# Footer
cat > templates/includes/footer.html << 'EOL'
<footer class="bg-dark text-white mt-5">
    <div class="container py-4">
        <div class="row">
            <div class="col-md-4">
                <h5>About VamosWay</h5>
                <p>Your trusted marketplace for unique products and services.</p>
            </div>
            <div class="col-md-4">
                <h5>Quick Links</h5>
                <ul class="list-unstyled">
                    <li><a href="#" class="text-white">Home</a></li>
                    <li><a href="#" class="text-white">Marketplace</a></li>
                    <li><a href="#" class="text-white">Contact Us</a></li>
                </ul>
            </div>
            <div class="col-md-4">
                <h5>Connect With Us</h5>
                <a href="#" class="text-white me-2"><i class="bi bi-facebook"></i></a>
                <a href="#" class="text-white me-2"><i class="bi bi-twitter"></i></a>
                <a href="#" class="text-white me-2"><i class="bi bi-instagram"></i></a>
            </div>
        </div>
        <div class="text-center mt-3">
            <p>&copy; 2023 VamosWay. All rights reserved.</p>
        </div>
    </div>
</footer>
EOL

# Homepage
cat > templates/index.html << 'EOL'
{% extends "base.html" %}

{% block title %}Home - VamosWay Marketplace{% endblock %}

{% block content %}
<div class="hero-section bg-primary text-white py-5 mb-5">
    <div class="container">
        <div class="row align-items-center">
            <div class="col-md-6">
                <h1 class="display-4 fw-bold">Welcome to VamosWay</h1>
                <p class="lead">Discover amazing products from independent sellers around the world.</p>
                <a href="{{ url_for('marketplace.home') }}" class="btn btn-light btn-lg">Shop Now</a>
            </div>
            <div class="col-md-6">
                <img src="{{ url_for('static', filename='images/marketplace-hero.png') }}" alt="Marketplace" class="img-fluid">
            </div>
        </div>
    </div>
</div>

<div class="container">
    <h2 class="text-center mb-4">Featured Products</h2>
    <div class="row">
        {% for product in featured_products %}
        <div class="col-md-3 mb-4">
            <div class="card h-100">
                <img src="{{ product.image_url or url_for('static', filename='images/placeholder-product.png') }}" 
                     class="card-img-top" alt="{{ product.name }}">
                <div class="card-body">
                    <h5 class="card-title">{{ product.name }}</h5>
                    <p class="card-text text-muted">{{ product.description|truncate(100) }}</p>
                    <p class="fw-bold">${{ "%.2f"|format(product.price) }}</p>
                </div>
                <div class="card-footer bg-white">
                    <a href="{{ url_for('marketplace.product_detail', product_id=product.id) }}" 
                       class="btn btn-primary btn-sm">View Details</a>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
</div>
{% endblock %}
EOL

# 11. Create static files
mkdir -p static/{css,js,images}

# Main CSS
cat > static/css/style.css << 'EOL'
:root {
    --primary-color: #3498db;
    --secondary-color: #2ecc71;
    --dark-color: #2c3e50;
    --light-color: #ecf0f1;
    --danger-color: #e74c3c;
    --success-color: #2ecc71;
    --warning-color: #f39c12;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f8f9fa;
}

.hero-section {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    border-radius: 0 0 20px 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.card {
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    border: none;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
}

.card-img-top {
    height: 200px;
    object-fit: cover;
}

.btn-primary {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
}

.btn-primary:hover {
    background-color: #2980b9;
    border-color: #2980b9;
}

.navbar {
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

footer {
    box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
}

.product-image {
    max-height: 400px;
    object-fit: contain;
}

.rating {
    color: var(--warning-color);
}

.stock-badge {
    font-size: 0.8rem;
}

.out-of-stock {
    color: var(--danger-color);
}

.in-stock {
    color: var(--success-color);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .hero-section {
        text-align: center;
        padding: 3rem 0;
    }
    
    .hero-section img {
        margin-top: 2rem;
    }
}
EOL

# Main JS
cat > static/js/main.js << 'EOL'
document.addEventListener('DOMContentLoaded', function() {
    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });
    
    // Cart functionality
    const cartButtons = document.querySelectorAll('.add-to-cart');
    cartButtons.forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const productId = this.dataset.productId;
            addToCart(productId);
        });
    });
    
    // Handle Stripe checkout
    const checkoutForm = document.getElementById('checkout-form');
    if (checkoutForm) {
        checkoutForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const stripe = Stripe('{{ config.STRIPE_PUBLIC_KEY }}');
            
            fetch('/create-checkout-session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token() }}'
                },
                body: JSON.stringify({
                    items: getCartItems()
                })
            })
            .then(response => response.json())
            .then(session => {
                return stripe.redirectToCheckout({ sessionId: session.id });
            })
            .then(result => {
                if (result.error) {
                    alert(result.error.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
        });
    }
    
    function addToCart(productId) {
        // Implement cart functionality
        console.log(`Added product ${productId} to cart`);
        updateCartBadge();
    }
    
    function updateCartBadge() {
        // Update cart badge count
        const badge = document.querySelector('.cart-badge');
        if (badge) {
            const currentCount = parseInt(badge.textContent) || 0;
            badge.textContent = currentCount + 1;
        }
    }
    
    function getCartItems() {
        // Return cart items for checkout
        return [];
    }
    
    // Review form validation
    const reviewForm = document.getElementById('review-form');
    if (reviewForm) {
        reviewForm.addEventListener('submit', function(e) {
            const rating = document.querySelector('input[name="rating"]:checked');
            if (!rating) {
                e.preventDefault();
                alert('Please select a rating');
            }
        });
    }
});
EOL

# 12. Create database migration and run it
flask db init
flask db migrate -m "Initial migration with marketplace"
flask db upgrade

# 13. Create admin user script
cat > create_admin.py << 'EOL'
from app import app, db
from models import User, UserProfile, Role

def create_admin():
    with app.app_context():
        # Create roles if they don't exist
        if not Role.query.filter_by(name='admin').first():
            admin_role = Role(name='admin', description='Administrator')
            db.session.add(admin_role)
        
        if not Role.query.filter_by(name='user').first():
            user_role = Role(name='user', description='Regular user')
            db.session.add(user_role)
        
        db.session.commit()
        
        admin_email = 'admin@vamosway.com'
        admin_password = 'SecureAdminPassword123!'
        
        admin_user = User.query.filter_by(email=admin_email).first()
        
        if not admin_user:
            admin_user = User(
                email=admin_email,
                password=generate_password_hash(admin_password, method='pbkdf2:sha256:600000'),
                email_verified=True,
                active=True
            )
            db.session.add(admin_user)
            db.session.commit()
            
            profile = UserProfile(
                user_id=admin_user.id,
                first_name='Admin',
                last_name='User'
            )
            db.session.add(profile)
            
            # Assign admin role
            admin_role = Role.query.filter_by(name='admin').first()
            admin_user.roles.append(admin_role)
            
            db.session.commit()
            print('Admin user created successfully!')
            print(f'Email: {admin_email}')
            print(f'Password: {admin_password}')
        else:
            print('Admin user already exists')

if __name__ == '__main__':
    create_admin()
EOL

# Run the script to create admin user
python create_admin.py

# 14. Create run script
cat > run.sh << 'EOL'
#!/bin/bash

# Start Redis
redis-server --daemonize yes

# Start Celery worker
celery -A app.celery worker --loglevel=info --detach

# Start Celery beat
celery -A app.celery beat --loglevel=info --detach

# Start Flask application
export FLASK_APP=app.py
export FLASK_ENV=production
gunicorn --bind 0.0.0.0:5000 --workers 4 app:app
EOL

chmod +x run.sh

# 15. Create README
cat > README.md << 'EOL'
# VamosWay Marketplace

A secure, scalable marketplace application built with Flask and Python.

## Features

- User authentication with email verification
- Role-based access control
- Product listing and management
- Shopping cart and checkout with Stripe integration
- Product reviews and ratings
- Admin dashboard
- RESTful API
- Celery for background tasks
- Redis for caching and rate limiting

## Requirements

- Python 3.8+
- PostgreSQL (recommended) or SQLite
- Redis
- Stripe account for payments

## Installation

1. Clone the repository
2. Create and activate virtual environment:
   ```bash
   python3 -m venv venv
   source venv/bin/activate



pip install -r requirements.txt
flask db init
flask db migrate
flask db upgrade
python create_admin.py

./run.sh
